/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

    -Purple Effects Plugin - Mark Matamoros Fall 2015
    -This is a guitar (bass and electric) effects plugin with tremolo, two gain stages, and stereo width.
    -Referenced files/sites:
        -++delay.jucer - Tom Erbe
        -stereo width: http://musicdsp.org/showArchiveComment.php?ArchiveID=173
 
  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
MmAssig3AudioProcessor::MmAssig3AudioProcessor()
{
}

MmAssig3AudioProcessor::~MmAssig3AudioProcessor()
{
}

//==============================================================================
const String MmAssig3AudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String MmAssig3AudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String MmAssig3AudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool MmAssig3AudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool MmAssig3AudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool MmAssig3AudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool MmAssig3AudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool MmAssig3AudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double MmAssig3AudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

//tells host the number of parameters
int MmAssig3AudioProcessor::getNumParameters()
{
    return 7;
}

//returns the name of a parameter to the host
const String MmAssig3AudioProcessor::getParameterName (int index)
{
    if(index == 0)
    {return "Gain One";}
    if(index == 1)
    {return "Gain Two";}
    if(index == 2)
    {return "LFO Rate";}
    if(index == 3)
    {return "LFO Depth";}
    if(index == 4)
    {return "Width";}
    if(index == 5)
    {return "Input";}
    if(index == 6)
    {return "Output";}
}

//returns the parameter value to the host
float MmAssig3AudioProcessor::getParameter (int index)
{
    if(index == 0)
    {return gain1;}
    if(index == 1)
    {return gain2;}
    if(index == 2)
    {return rateLFO;}
    if(index == 3)
    {return depth;}
    if(index == 4)
    {return width;}
    if(index == 5)
    {return inPut;}
    if(index == 6)
    {return outPut;}
}

//returns parameter string value to the host
const String MmAssig3AudioProcessor::getParameterText (int index)
{
    if(index == 0)
    {return String (gain1);}
    if(index == 1)
    {return String (gain2);}
    if(index == 2)
    {return String (rateLFO);}
    if(index == 3)
    {return String (depth);}
    if(index == 4)
    {return String (width);}
    if(index == 5)
    {return String (inPut);}
    if(index == 6)
    {return String (outPut);}
}

void MmAssig3AudioProcessor::setParameter (int index, float newValue)
{
    if(index == 0)
    {gain1 = newValue;}
    if(index == 1)
    {gain2 = newValue;}
    if(index == 2)
    {rateLFO = newValue;}
    if(index == 3)
    {depth = newValue;}
    if(index == 4)
    {width = newValue;}
    if(index == 5)
    {inPut = newValue;}
    if(index == 6)
    {outPut = newValue;}
}

int MmAssig3AudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int MmAssig3AudioProcessor::getCurrentProgram()
{
    return 0;
}

void MmAssig3AudioProcessor::setCurrentProgram (int index)
{
}

const String MmAssig3AudioProcessor::getProgramName (int index)
{
    return String();
}

void MmAssig3AudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void MmAssig3AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    // Use this method as the place to do any pre-playback
    // initialisation that you need..
}

void MmAssig3AudioProcessor::releaseResources()
{
    // When playback stops, you can use this as an opportunity to free up any
    // spare memory, etc.
}

void MmAssig3AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    int32_t sampnum;
    float inputL;
    float inputR;
    float outputL;
    float outputR;
    float gainOne;
    float gainTwo;
    
    float* leftData = buffer.getWritePointer(0);
    float* rightData = buffer.getWritePointer(1);
    
    for(sampnum = 0; sampnum < buffer.getNumSamples(); sampnum++)
    {
        //calculate sine wave steps - 25 hz max
        lfo_phase_inc = (rateLFO * 25.0f) / getSampleRate();
        lfo_phase += lfo_phase_inc;
        
        inputL = *(leftData + sampnum);
        
        inputL = inputL * inPut;
        
        //create copy of original left signal
        originalInputL = inputL;
        
        //multiply sample amplitude by 5
        //lower input control to counter clipping
        gainOne = gain1 * 5.0f;
        gainTwo = gain2 * 5.0f;
        
        //Tremolo
        if (rateLFO > 0)
        {
            //modulate amplitude for tremolo
            inputL = inputL * ((sinf(twopi * lfo_phase)) + 1.0f) * 0.5f;
            
            //mix wet to dry signal for depth
            inputL = (inputL * depth) + (originalInputL * (1.0f - depth));
        }
        
        //apply the first gain - with limits (clipping)
        //based upon Tom Erbe's soft Distortion
        inputL = gainOne * 1.5f * inputL - 0.5f * inputL * inputL * inputL;
        if (inputL > 1.0f) {inputL = 1.0f;}
        if (inputL < -1.0f) {inputL = -1.0f;}
        
        //apply the second gain - with limits (clipping)
        //Based on Charle Dodge's Distortion - "Computer Music" p147 - "4x^3+3x"
        inputL = gainTwo * 4.0f * inputL * inputL * inputL - 3.0f * inputL;
        if (inputL > 1.0f) {inputL = 1.0f;}
        if (inputL < -1.0f) {inputL = -1.0f;}
        
        outputL = inputL * outPut;
        
        //process right channel
        if(buffer.getNumChannels() == 2)
        {
            inputR = *(rightData + sampnum);
            
            inputR = inputR * inPut;
            
            //create copy of right signal
            originalInputR = inputR;
            
            //multiply sample amplitude by 5
            //lower input control to counter clipping
            gainOne = gain1 * 5.0f;
            gainTwo = gain2 * 5.0f;
            
            //Tremolo
            if (rateLFO > 0)
            {
                //modulate amplitude for tremolo
                inputR = inputR * ((sinf(twopi * lfo_phase)) + 1.0f) * 0.5f;
                
                //mix wet to dry signal for depth
                inputR = (inputR * depth) + (originalInputR * (1.0f - depth));
            }
            
            //apply the first gain - with limits (clipping)
            //Tom Erbe's soft Distortion
            inputR = gainOne * 1.5f * inputR - 0.5f * inputR * inputR * inputR;
            if (inputR > 1.0f) {inputR = 1.0f;}
            if (inputR < -1.0f) {inputR = -1.0f;}
            
            //apply the second gain - with limits (clipping)
            //Based on Charle Dodge's Distortion - "Computer Music" p147 - "4x^3+3x"
            inputR = gainTwo * 4.0f * inputR * inputR * inputR - 3.0f * inputR;
            if (inputR > 1.0f) {inputR = 1.0f;}
            if (inputR < -1.0f) {inputR = -1.0f;}
            
            //Apply stereo width - source: http://musicdsp.org/showArchiveComment.php?ArchiveID=173
            //Posted by "gtekprog" (Correction to original posting)
            float stereo = inputL - inputR;
            stereo = stereo * width;
            inputL = inputR + stereo;
            inputR = inputL - stereo;
            
            outputR = inputR * outPut;
            
            //right out
            *(rightData + sampnum) = outputR;
        }
        
        //left out
        *(leftData + sampnum) = outputL;
        }
}

//==============================================================================
bool MmAssig3AudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* MmAssig3AudioProcessor::createEditor()
{
    return new MmAssig3AudioProcessorEditor (*this);
}

//==============================================================================
void MmAssig3AudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
    
    XmlElement XmlState("pluginState");
    
    XmlState.setAttribute(String("gain1"), gain1);
    XmlState.setAttribute(String("gain2"), gain2);
    XmlState.setAttribute(String("rateLFO"), rateLFO);
    XmlState.setAttribute(String("depth"), depth);
    XmlState.setAttribute(String("width"), width);
    XmlState.setAttribute(String("inPut"), inPut);
    XmlState.setAttribute(String("outPut"), outPut);
    
    copyXmlToBinary(XmlState, destData);
}

void MmAssig3AudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
    
    ScopedPointer<XmlElement> XmlState(getXmlFromBinary(data, sizeInBytes));
    
    if (XmlState != 0)
    {
        if (XmlState->hasTagName("pluginState"))
        {
            gain1 = float(XmlState->getDoubleAttribute(String("gain1"), gain1));
            gain2 = float(XmlState->getDoubleAttribute(String("gain2"), gain2));
            rateLFO = float(XmlState->getDoubleAttribute(String("rateLFO"), rateLFO));
            depth = float(XmlState->getDoubleAttribute(String("depth"), depth));
            width = float(XmlState->getDoubleAttribute(String("width"), width));
            inPut = float(XmlState->getDoubleAttribute(String("inPut"), inPut));
            outPut = float(XmlState->getDoubleAttribute(String("outPut"), outPut));
        }
    }
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MmAssig3AudioProcessor();
}
